---
title: "Data Visualization in R"
subtitle: "MultiPanel and Layout"
author: "Fushuai Jiang"
date: "`r Sys.Date()`"
output: beamer_presentation

urlcolor: blue

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,  message = FALSE)
knitr::opts_chunk$set(fig.align='center', out.width = "75%")
library(ggplot2)
library(socviz)
library(tidyverse)
library(patchwork)
library(ggcorrplot)
library(corrplot)
library(GGally)
```


# `facet_`

## Main functions: `facet_wrap()` and `facet_grid()`

- Reference: chapter 9 and chapter 16 of [ggplot2: Elegant Graphics for Data Analysis](https://ggplot2-book.org/facet.html)


- The `facet_` function allows us to make visually effective multi-grid plots, where each grid displays a different value of the **faceted variable**

- **Benefit:** declutter a busy picture for better comparison

- `facet_Wrap()` splits (facets) on **one variable**

- `facet_grid` splits on multiples (can get pretty busy pretty quickly)



## Main functions: `facet_wrap()` and `facet_grid()`

![](images/08_facet.png)

\tiny From *ggplot2: Elegant Graphics for Data Analysis* 


## Example: `oecd_le`

\tiny
```{r}
library(socviz, ggplot2)
p <- ggplot(oecd_le, aes(x = year, y = lifeexp))
p + geom_line(aes(group = country)) # + labels
```



## `facet_wrap()` example: `oecd_le`

- It makes a long ribbon of panels (determined by `unique(data$var)`)

- `ncol` or `nrow` controls the dimension (only need to specify one of them)

- `dir` contorls the direction of the wrap **h**orizontal or **v**ertical


```{r}
p + facet_wrap(~country)
```


## `facet_wrap()` example: `oecd_le`

```{r}
p + facet_wrap(~country, nrow = 4, dir = "v")
```

## `facet_wrap()` example: `oecd_le`

```{r}
p + facet_wrap(~country, ncol = 7, dir = "h") + 
  geom_line()
```

## `facet_wrap()`: USA vs others

Suppose I want to compare USA vs other countries. How to fix the following plot?

```{r}
p + facet_wrap(~is_usa) + geom_line()
```
## `facet_wrap()`: USA vs others

```{r}
p + facet_wrap(~is_usa) + geom_line(aes(group = country))
```

What else can we do to tell a better story?

## 

```{r}
p2 <- p + facet_wrap(~is_usa) + geom_line(aes(group = country), alpha = 0.4) + 
  geom_smooth(se = F, color= "red", linewidth = 1.7)
p2
```

## Labeling with faceted plots

```{r}
fac.labs <- c(other = "Non-US OECD countries", 
              usa  = "USA")
p2 + facet_wrap(~is_usa, 
                labeller = labeller(is_usa = fac.labs)) + 
labs(title = "Life Expectancy of USA vs non-US OECD countries", x = "Year", y = "Life Expectancy (in years)", caption = "Source: OECD data") + ggthemes::theme_tufte()
```


## Named Character Vectors in `R`

- The `fac.lab` object is a **named character vector** in `R`. These are quite useful for custom labeling

```{r}
fac.labs
typeof(fac.labs)
is.vector(fac.labs)
names(fac.labs)
```


## `facet_Wrap()` example: diamonds

```{r}
ggplot(diamonds, aes(x = clarity, y = price)) + 
  geom_boxplot(aes(color = clarity)) + facet_wrap(~cut) + 
  scale_y_log10(labels = scales::dollar)
```



## `facet_grid`



`facet_grid()` lays out plots in a 2d grid:

- `. ~ var` spreads the values of `var` across the columns
  
- `var ~ .` spreads the values of `var` across the rows
  
- `var1 ~ var2` spreads the values of `var1` across the rows, and `var2` across the columns
  
- The `.` is a placeholder, facilitating the comparison of the corresponding positions
  

## `facet_grid()` on diamonds

```{=latex}
\begin{columns}
\column{0.5\textwidth}
```

```{r, out.width="100%"}
ggplot(diamonds) + 
  facet_grid(. ~ cut)
```

```{=latex}
\column{0.5\textwidth}
```

```{r, out.width="100%"}
ggplot(diamonds) + 
  facet_grid(clarity ~ .)
```

```{=latex}
\end{columns}
```






## `facet_grid()` on diamonds

```{r, message=F, warning = F}
ggplot(dplyr::slice_sample(diamonds, n = 5000)) + 
  facet_grid(clarity ~ cut) + 
  geom_point(aes(x = carat, y = price), size = 0.6, alpha = 0.4) + 
  geom_smooth(aes(x = carat, y = price), se = F)
```




## `facet_grid()` on `mpg`, labeling

```{r}
str(mpg)
```
## Exercise: `facet_grid()` on `mpg`



- Suppose we want to visualize the relationship between the engine displacement (`displ`) and the highway fuel efficiency (`mpg`), 
- categorized by drive train (`drv`) and the types of car (`class`), 
- and use colors to distinguish years.


## `facet_grid()` on `mpg`

```{r}
p <- ggplot(mpg, aes(x=displ, y = hwy))+ 
  geom_point(aes(color = as.factor(year))) + 
  facet_grid(class~drv)
p
```




## `facet_grid()` on `mpg`, LABELING


```{r}
unique(mpg$drv)
unique(mpg$class)
```

```{r}
r_labs <- c("4" = "Four Wheel Drive", 
            "f"= "Front Wheel Drive", 
            "r" = "Rear Wheel Drive")
c_labs <- c('2seater' ="Two seater", 
'compact'="Compact", 'midsize'="Mid-size", 
'minivan'="Minivan", 'pickup'="Pickup truck", 
'subcompact'="Subcompact", 'suv'="Suv")
```




## `facet_grid()` on `mpg`, LABELING

```{r}
p + facet_grid(drv~class,labeller = labeller(
  drv = r_labs, class = c_labs))
```




## Axial scaling


In `facet_`, you can control  if position scales are the same in all panels (`fixed`) or allowed to vary between panels (`free`) with the scales parameter

- `scales = "fixed"`: both x and y scales are fixed

- `scales = "free_x"` or `"free_y"`: free one, fix the other

- `scales = "free"`: both free

- **Why fixed?** -- easier to see patterns across panels

- **Why free?** -- easier to see patterns within panels


## Default: fixed scales

```{r}
p + geom_abline(intercept = c(0,0), slope =10)
# a reference line with intercept at the origin 
# and slope 10, see ?geom_abline
```


## `scales = "free_y"`

```{r}
p + geom_abline(intercept = c(0,0), slope =10) + 
  facet_grid(class~drv, scales = "free_y")
```

## `scales = "free"`

```{r}
p + geom_abline(intercept = c(0,0), slope =10) + 
  facet_grid(class~drv, scales = "free")
```





## When free scaling matters

```{r}
# ?economics_long
str(economics_long)
unique(economics_long$variable)
```


## When free scaling matters

```{r}
ggplot(economics_long, aes(date, value)) + geom_line() + 
  facet_wrap(~variable, ncol=1)
```





## When free scaling matters

```{r}
ggplot(economics_long, aes(date, value)) + geom_line() + 
  facet_wrap(~variable, ncol=1, scales = "free_y")
```


- How would you set the $y$-label in this plot?




## Labeling, in faceted variable names

```{r, echo = F, out.width="100%"}
var.labs = c(
  "pce" = "Personal Consumption Expenditures, in $ Billions",
  "pop" = "Total Population, in thousands",
  "uempmed" = "Median Duration of Unemployment, in weeks",
  "unemploy" = "Number of Unemployed, in thousands"
)
ggplot(economics_long, aes(date, value)) + geom_line() + 
  facet_wrap(~variable, ncol=1, scales = "free_y", 
             labeller = labeller(variable = var.labs)) + 
  labs(
    title = "US economics time series visualization",
    x = "Date", y = "",
    caption = "Source: economics long dataset."
  ) + 
  ggthemes::theme_excel_new()
```


## Labeling, in caption

```{r, echo = F, out.width = "100%"}
var.labs = c(
  "pce" = "Personal Consumption Expenditures",
  "pop" = "Total Population",
  "uempmed" = "Median Duration of Unemployment",
  "unemploy" = "Number of Unemployed"
)
ggplot(economics_long, aes(date, value)) + geom_line() + 
  facet_wrap(~variable, ncol=1, scales = "free_y", 
             labeller = labeller(variable = var.labs)) + 
  labs(
    title = "US economics time series visualization",
    x = "Date", y = "",
    caption = "Source: economics long dataset. \nUnits from top to bottom: billions of dollars, thousands, no units, weeks, thousands"
  ) + 
  ggthemes::theme_fivethirtyeight()
```




## Scales for categorical variables

```{r}
mpg2 <- subset(mpg, cyl != 5 & drv %in% c("4", "f") & class != "2seater")
dplyr::slice_sample(mpg2,n=5)
```
Let's compare the city fuel efficiency by manufacturer. 

## `space` in `facet_grid()`

```{r}
ggplot(mpg2, aes(cty, model)) + geom_point() + 
  facet_grid(manufacturer ~ ., scales = "free") + 
  ggthemes::theme_solarized_2() +
  theme(strip.text.y = element_text(angle = 0))
```



## `space` in `facet_grid()`

`facet_grid()` has an additional parameter called `space` that takes the same value as `scales`

- `space` is free -- each column/row will have width/height proportional to the data range

- Yields **equal scaling across the whole plot** (1 cm on each panel)

- Useful for categorical scales


## `space` in `facet_grid()`

```{r}
ggplot(mpg2, aes(cty, model)) + geom_point() + 
  facet_grid(manufacturer ~ ., 
             scales = "free", space = "free") + 
  ggthemes::theme_solarized_2() + 
  theme(strip.text.y = element_text(angle = 0))
```



## Example: `gapminder` + `oecd_le`, alternative visualization

```{r, warning = F}
oecd2 <- left_join(socviz::oecd_le, gapminder::gapminder, by = "country")
sum(is.na(oecd2$continent))
unique(oecd2[is.na(oecd2$continent), ]$country)
```

```{r}
oecd2[oecd2$country=="Korea",]$continent <- "Asia"
oecd2[oecd2$country=="Luxembourg",]$continent <- "Europe"
oecd2[oecd2$country=="Estonia",]$continent <- "Europe"
oecd2[oecd2$country=="Latvia",]$continent <- "Europe"
```


## Example: `gapminder` + `oecd_le`


```{r}
ggplot(oecd2, aes(lifeexp, y = country)) + geom_point() + 
  facet_grid(continent~., scales = "free", space = "free") + 
  ggthemes::theme_fivethirtyeight() + 
  theme(strip.text.y = element_text(angle = 0))
```


## Without cleaning the data?


```{r, warning = F}
ggplot(left_join(socviz::oecd_le, gapminder::gapminder, by = "country"), aes(lifeexp, y = country)) + geom_point() + 
  facet_grid(continent~., scales = "free", space = "free") + 
  ggthemes::theme_fivethirtyeight() + 
  theme(strip.text.y = element_text(angle = 0))
```


## Faceting vs Grouping?

- **Faceting:**  each group is far apart (in its own panel), no group overlap

  - Good if the groups do overlap a lot
  - Hard to see small differences

- **Grouping:** different groups all overlap in the same plot
  - Good if the groups have separation
  - Easier to spot small differences
  
  
## Faceting vs Grouping?
\tiny
```{r}
library(gapminder)
library(patchwork)
p1 <- ggplot(subset(gapminder, year %in% c(1952, 2007)), aes(gdpPercap, lifeExp, color = as.factor(year))) + geom_point() + scale_x_log10()
p2 <- ggplot(subset(gapminder, year %in% c(1952, 2007)), aes(gdpPercap, lifeExp, color = as.factor(year))) + geom_point() + scale_x_log10() + facet_wrap(~year)
p1 + p2
```


## Faceting continous variables


First discretize them! `ggplots` has three helper functions:

- `cut_interval(x,n)`: divide `x` into `n` bins of the same length

- `cut_width(x,width)`: divide `x` into bins of width `width`

- `cut_number(x, n = N)`: divide `x` into `N` bins each with approximately the same number of points


## Faceting continous variables: `carat` in `diamonds`


```{r}
# diamonds are just rocks
rocks <- diamonds
# bins of width 1
rocks$by_w <- cut_width(rocks$carat, 1)
# six bins of equal length
rocks$by_l <- cut_interval(rocks$carat, 6)
# eight bins of roughly equal number point
rocks$by_n <- cut_number(rocks$carat, 8)

```




## Faceting continous variables: `carat` in `diamonds`

```{r}
p1 <- ggplot(rocks, aes(cut,price)) + geom_boxplot() + 
  facet_wrap(~by_w, nrow = 2)
p1
```



## Faceting continous variables: `carat` in `diamonds`

```{r}
p2 <- ggplot(rocks, aes(cut,price)) + geom_boxplot() + 
  facet_wrap(~by_l, nrow = 2)
p2
```



## Faceting continous variables: `carat` in `diamonds`

```{r}
p3 <- ggplot(rocks, aes(cut,price)) + geom_boxplot() + 
  facet_wrap(~by_n, nrow = 2)
p3
```



# Patchwork


## Patchwork

`patchwork`: show multiple plots side-by-side using `+`

```{r}
library(patchwork)
p1 + p2 + p3
```

## Arranging the `geom_` side-by-side

```{r}
p1 <- ggplot(mpg) + 
  geom_point(aes(x = displ, y = hwy))
p2 <- ggplot(mpg) + 
  geom_bar(aes(x = as.character(year), fill = drv), position = "dodge") + labs(x = "year")
p3 <- ggplot(mpg) + 
  geom_density(aes(x = hwy, fill = drv), color = NA) + facet_grid(rows = vars(drv))
p4 <- ggplot(mpg) + 
  stat_summary(aes(x = drv, y = hwy, fill = drv), geom = "col", fun.data = mean_se) + 
  stat_summary(aes(x = drv, y = hwy), geom = "errorbar", fun.data = mean_se, width = 0.5)
```

## 
```{r}
p1+p2+p3+p4
```



## `+plot_layout()`

```{r}
p1 + p2 + p3 + p4 +  plot_layout(nrow = 1)
```

## Forcing a single row `|` 

```{r}
p1 | p2
```

## Forcing a single column `/`

```{r}
p1 / p2
```



## Mix and match

```{r}
((p1 + p2) / p3) | p4 
```


## Using the `design` function

```{r}
picasso <- "AAB
C#B
CDD"
p1 + p2 + p3 + p4 + plot_layout(design = picasso)
```

## Removing redundant legends using `guides`

```{r}
p1 + p2 + p3 + p4 + plot_layout(
  design = picasso,
  guides = "collect")
```


## You can group them as well

```{r}
p12 <- p1 + p2
p12 | p4 
```

## Modifying all plots

What's wrong with the following plots

```{r}
p12 <- p1 + p2
p12 | p4 + ggthemes::theme_solarized(light = F)
```

## Modifying all plots

The fix: using `&` and change the order of the operation (expect trial and error :-))

```{r}
(p12 | p4) & ggthemes::theme_solarized(light = F)
```

## Plots and annotations

After assemply, plots are a single object and annotation (via `plot_annotation`) works on the whole figure

```{r}
p123 <- p1 | (p2 / p3)
p123 + plot_annotation(
    title = "Effect of Drive Train", 
    caption = "Source: mpg dataset", 
    tag_levels = "a")
```



## Plots and annotations

There are a \huge HUGE \normalsize number of annotation options. More on this soon!

```{r}
p123[[2]] <- p123[[2]] + plot_layout(tag_level = "new")
p123 + plot_annotation(tag_levels = c("A", "1"))
```



## Plots within Plots via `inset_element()`


```{r}
p1 + inset_element(p2, 
  left = 0.5, right = 0.9, bottom = 0.4, top = 0.95) + 
  plot_annotation(tag_levels = "i")& 
  ggthemes::theme_excel()
```















